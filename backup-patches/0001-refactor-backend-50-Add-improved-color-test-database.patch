From c47412c8e65f563a3cd7aef748f37078a8b52198 Mon Sep 17 00:00:00 2001
From: Robbie <rgbenn27@colby.edu>
Date: Thu, 13 Nov 2025 22:40:23 -0500
Subject: [PATCH 01/26] refactor(backend)/#50: Add improved color test database
 models with validation and helper methods

---
 api/models.py | 390 +++++++++++++++++++++++++++++++++++---------------
 1 file changed, 273 insertions(+), 117 deletions(-)

diff --git a/api/models.py b/api/models.py
index 010f205..9b69d6f 100644
--- a/api/models.py
+++ b/api/models.py
@@ -1,6 +1,8 @@
 from datetime import datetime
 from flask_sqlalchemy import SQLAlchemy
 import enum
+from sqlalchemy import CheckConstraint, Index
+import math
 
 db = SQLAlchemy()
 
@@ -213,106 +215,6 @@ class ScreeningSession(db.Model):
         self.events.append(ScreeningEvent(step=step, event=event, details=details or {}))
         return self
 
-    # Note: The following methods have been moved to service classes:
-    # - compute_selected_types → TypeSelectionService.compute_selected_types
-    # - compute_eligibility_and_exit → EligibilityService.compute_eligibility_and_exit
-    # - compute_recommendations → RecommendationService.compute_recommendations
-    
-    # def compute_selected_types(self):
-    #     """
-    #     Build a canonical list from type_choice (yes/sometimes only).
-    #     """
-    #     out = []
-    #     tc = self.type_choice
-    #     if not tc:
-    #         return out
-    #     if tc.grapheme in {Frequency.yes, Frequency.sometimes}:
-    #         out.append("Grapheme – Color")
-    #     if tc.music in {Frequency.yes, Frequency.sometimes}:
-    #         out.append("Music – Color")
-    #     if tc.lexical in {Frequency.yes, Frequency.sometimes}:
-    #         out.append("Lexical – Taste")
-    #     if tc.sequence in {Frequency.yes, Frequency.sometimes}:
-    #         out.append("Sequence – Space")
-    #     if tc.other and tc.other.strip():
-    #         out.append(f"Other: {tc.other.strip()}")
-    #     return out
-
-    # def compute_eligibility_and_exit(self):
-    #     """
-    #     Apply client-side flow:
-    #       - If any health flags: exit 'BC'
-    #       - If definition = 'no': exit 'A'
-    #       - If pain_emotion = 'yes': exit 'D'
-    #       - If no types selected: exit 'NONE'
-    #       - Else eligible = True
-    #     """
-    #     # Health (step 1)
-    #     if self.health and (self.health.drug_use or self.health.neuro_condition or self.health.medical_treatment):
-    #         self.eligible = False
-    #         self.exit_code = "BC"
-    #         return
-
-    #     # Definition (step 2)
-    #     if self.definition and self.definition.answer == YesNoMaybe.no:
-    #         self.eligible = False
-    #         self.exit_code = "A"
-    #         return
-
-    #     # Pain & Emotion (step 3)
-    #     if self.pain_emotion and self.pain_emotion.answer == YesNo.yes:
-    #         self.eligible = False
-    #         self.exit_code = "D"
-    #         return
-
-    #     # Types (step 4)
-    #     types = self.compute_selected_types()
-    #     self.selected_types = types
-    #     if not types:
-    #         self.eligible = False
-    #         self.exit_code = "NONE"
-    #         return
-
-    #     # Otherwise eligible
-    #     self.eligible = True
-    #     self.exit_code = None
-
-    # def compute_recommendations(self):
-    #     """
-    #     Derive recommended tests from selected_types.
-    #     Stores JSON and fills normalized table. If a Test exists by name, link it.
-    #     """
-    #     mapping = {
-    #         "Grapheme – Color": "Grapheme-Color",
-    #         "Music – Color": "Music-Color",
-    #         "Lexical – Taste": "Lexical-Gustatory",
-    #         "Sequence – Space": "Sequence-Space",
-    #     }
-
-    #     results = []
-    #     # Clear existing rows if recomputing
-    #     self.recs.clear()
-
-    #     for idx, label in enumerate(self.selected_types or []):
-    #         base_name = mapping.get(label, label)  # fallback
-    #         reason = f"Selected type: {label}"
-    #         test_row = Test.query.filter(Test.name.ilike(base_name)).first()
-    #         rec = ScreeningRecommendedTest(
-    #             position=idx + 1,
-    #             suggested_name=base_name,
-    #             reason=reason,
-    #             test_id=test_row.id if test_row else None,
-    #         )
-    #         self.recs.append(rec)
-    #         results.append({
-    #             "position": idx + 1,
-    #             "name": base_name,
-    #                         "reason": reason,
-    #             "test_id": test_row.id if test_row else None
-    #         })
-
-    #     self.recommended_tests = results
-
     def finalize(self):
         """Call when the session is done (or at any decision point)."""
         # Import services here to avoid circular imports
@@ -434,26 +336,63 @@ class ScreeningRecommendedTest(db.Model):
 
 
 # ======================================================
-# COLOR TEST MODELS (existing)
+# COLOR TEST MODELS (IMPROVED & COMPLETE)
 # ======================================================
 
 class ColorStimulus(db.Model):
     """Stimuli table for color-based tests"""
     __tablename__ = "color_stimuli"
+    __table_args__ = (
+        CheckConstraint('r >= 0 AND r <= 255', name='check_r_range'),
+        CheckConstraint('g >= 0 AND g <= 255', name='check_g_range'),
+        CheckConstraint('b >= 0 AND b <= 255', name='check_b_range'),
+        Index('idx_cs_set_owner', 'set_id', 'owner_researcher_id'),
+        Index('idx_cs_family_trigger', 'family', 'trigger_type'),
+    )
 
     id = db.Column(db.Integer, primary_key=True)
     set_id = db.Column(db.Integer, nullable=True, index=True)
     description = db.Column(db.String(255), nullable=True)
-    owner_researcher_id = db.Column(db.Integer, nullable=True, index=True)
-    family = db.Column(db.String(32), nullable=False, default="color")
+    
+    # Foreign key to Researcher
+    owner_researcher_id = db.Column(db.Integer, db.ForeignKey('researchers.id'), nullable=True, index=True)
+    owner = db.relationship('Researcher', backref='color_stimuli', lazy='joined')
+    
+    family = db.Column(db.String(32), nullable=False, default="color", index=True)
     r = db.Column(db.Integer, nullable=False)
     g = db.Column(db.Integer, nullable=False)
     b = db.Column(db.Integer, nullable=False)
-    trigger_type = db.Column(db.String(64), nullable=True)
+    trigger_type = db.Column(db.String(64), nullable=True, index=True)
 
     created_at = db.Column(db.DateTime, default=datetime.utcnow)
     updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
 
+    # Relationships to other tables
+    trials = db.relationship("ColorTrial", back_populates="stimulus", lazy="dynamic", cascade="all, delete-orphan")
+    test_data_entries = db.relationship("TestData", back_populates="stimulus", lazy="dynamic")
+    analyzed_data_entries = db.relationship("AnalyzedTestData", back_populates="stimulus", lazy="dynamic")
+
+    def __repr__(self):
+        return f"<ColorStimulus id={self.id} RGB=({self.r},{self.g},{self.b}) trigger={self.trigger_type}>"
+
+    @property
+    def hex_color(self):
+        """Returns the color as a hex string"""
+        return f"#{self.r:02x}{self.g:02x}{self.b:02x}"
+
+    @property
+    def rgb_tuple(self):
+        """Returns the color as an (r, g, b) tuple"""
+        return (self.r, self.g, self.b)
+
+    def distance_to(self, r, g, b):
+        """Calculate Euclidean distance to another RGB color"""
+        return math.sqrt(
+            (self.r - r)**2 +
+            (self.g - g)**2 +
+            (self.b - b)**2
+        )
+
     def to_dict(self):
         return {
             "id": self.id,
@@ -464,34 +403,91 @@ class ColorStimulus(db.Model):
             "r": self.r,
             "g": self.g,
             "b": self.b,
-            "hex": f"#{self.r:02x}{self.g:02x}{self.b:02x}",
+            "hex": self.hex_color,
             "trigger_type": self.trigger_type,
+            "created_at": self.created_at.isoformat() if self.created_at else None,
+            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
         }
 
 
 class ColorTrial(db.Model):
     """Individual color test trial results"""
     __tablename__ = "color_trials"
+    __table_args__ = (
+        CheckConstraint('selected_r >= 0 AND selected_r <= 255', name='check_selected_r_range'),
+        CheckConstraint('selected_g >= 0 AND selected_g <= 255', name='check_selected_g_range'),
+        CheckConstraint('selected_b >= 0 AND selected_b <= 255', name='check_selected_b_range'),
+        CheckConstraint('response_ms >= 0', name='check_response_time_positive'),
+        Index('idx_ct_participant_created', 'participant_id', 'created_at'),
+        Index('idx_ct_stimulus_trial', 'stimulus_id', 'trial_index'),
+    )
 
     id = db.Column(db.Integer, primary_key=True)
-    participant_id = db.Column(db.String(64), nullable=True, index=True)
-
+    
+    # Foreign key to Participant - using string for now to match your current schema
+    # You can change this to Integer + ForeignKey later if needed
+    participant_id = db.Column(db.String(64), nullable=False, index=True)
+    
+    # Foreign key to ColorStimulus
     stimulus_id = db.Column(
         db.Integer,
         db.ForeignKey("color_stimuli.id", ondelete="SET NULL"),
         nullable=True,
         index=True,
     )
-    stimulus = db.relationship("ColorStimulus", lazy="joined")
+    stimulus = db.relationship("ColorStimulus", back_populates="trials", lazy="joined")
 
+    # Trial details
     trial_index = db.Column(db.Integer, nullable=True)
+    
+    # Response data
     selected_r = db.Column(db.Integer, nullable=True)
     selected_g = db.Column(db.Integer, nullable=True)
     selected_b = db.Column(db.Integer, nullable=True)
     response_ms = db.Column(db.Integer, nullable=True)
+    
+    # Metadata (device info, browser, etc.)
     meta_json = db.Column(db.JSON, nullable=True)
 
-    created_at = db.Column(db.DateTime, default=datetime.utcnow)
+    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
+
+    def __repr__(self):
+        return f"<ColorTrial id={self.id} P={self.participant_id} trial={self.trial_index}>"
+
+    @property
+    def selected_hex_color(self):
+        """Returns the selected color as a hex string"""
+        if all(v is not None for v in [self.selected_r, self.selected_g, self.selected_b]):
+            return f"#{self.selected_r:02x}{self.selected_g:02x}{self.selected_b:02x}"
+        return None
+
+    @property
+    def selected_rgb_tuple(self):
+        """Returns the selected color as an (r, g, b) tuple"""
+        if all(v is not None for v in [self.selected_r, self.selected_g, self.selected_b]):
+            return (self.selected_r, self.selected_g, self.selected_b)
+        return None
+
+    def color_distance(self):
+        """Calculate Euclidean distance between stimulus and selected colors"""
+        if self.stimulus and all(v is not None for v in [self.selected_r, self.selected_g, self.selected_b]):
+            return self.stimulus.distance_to(self.selected_r, self.selected_g, self.selected_b)
+        return None
+
+    def is_exact_match(self):
+        """Check if selected color exactly matches stimulus"""
+        if self.stimulus and all(v is not None for v in [self.selected_r, self.selected_g, self.selected_b]):
+            return (
+                self.stimulus.r == self.selected_r and
+                self.stimulus.g == self.selected_g and
+                self.stimulus.b == self.selected_b
+            )
+        return False
+
+    def is_close_match(self, threshold=30):
+        """Check if selected color is within threshold distance of stimulus"""
+        distance = self.color_distance()
+        return distance is not None and distance <= threshold
 
     def to_dict(self):
         return {
@@ -502,51 +498,88 @@ class ColorTrial(db.Model):
             "selected_r": self.selected_r,
             "selected_g": self.selected_g,
             "selected_b": self.selected_b,
+            "selected_hex": self.selected_hex_color,
             "response_ms": self.response_ms,
+            "color_distance": self.color_distance(),
+            "is_exact_match": self.is_exact_match(),
             "meta_json": self.meta_json or {},
-            "created_at": self.created_at.isoformat(),
+            "created_at": self.created_at.isoformat() if self.created_at else None,
         }
 
 
 class TestData(db.Model):
     """Aggregated color test metrics (CCT/SCT results)"""
     __tablename__ = "test_data"
+    __table_args__ = (
+        Index('idx_td_user_test_created', 'user_id', 'test_id', 'created_at'),
+        Index('idx_td_user_test_type', 'user_id', 'test_type'),
+        Index('idx_td_session_test', 'session_id', 'test_type'),
+        Index('idx_td_owner_family', 'owner_researcher_id', 'family'),
+    )
 
     id = db.Column(db.Integer, primary_key=True)
+    
+    # User linkage - string ID to match participant_id in ColorTrial
     user_id = db.Column(db.String(64), index=True, nullable=True)
-    test_id = db.Column(db.Integer, nullable=True, index=True)
-    owner_researcher_id = db.Column(db.Integer, nullable=True, index=True)
+    
+    # Foreign key to Test
+    test_id = db.Column(db.Integer, db.ForeignKey('tests.id'), nullable=True, index=True)
+    test = db.relationship('Test', backref='test_data_entries', lazy='joined')
+    
+    # Foreign key to Researcher
+    owner_researcher_id = db.Column(db.Integer, db.ForeignKey('researchers.id'), nullable=True, index=True)
+    owner = db.relationship('Researcher', backref='test_data_entries', lazy='joined')
+    
     session_id = db.Column(db.Integer, nullable=True, index=True)
 
+    # Foreign key to ColorStimulus
     stimulus_id = db.Column(
         db.Integer,
         db.ForeignKey("color_stimuli.id", ondelete="SET NULL"),
         nullable=True,
         index=True,
     )
-    stimulus = db.relationship("ColorStimulus", backref="test_data")
+    stimulus = db.relationship("ColorStimulus", back_populates="test_data_entries", lazy="joined")
 
-    test_type = db.Column(db.String(64), nullable=True)
+    # Test metadata
+    test_type = db.Column(db.String(64), nullable=True, index=True)
     stimulus_type = db.Column(db.String(64), nullable=True)
-    family = db.Column(db.String(16), nullable=False, default="color")
+    family = db.Column(db.String(16), nullable=False, default="color", index=True)
     locale = db.Column(db.String(16), nullable=True)
 
-    created_at = db.Column(db.DateTime, default=datetime.utcnow)
+    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
+    
+    # Trial information
     trial = db.Column(db.Integer, nullable=True)
+    
+    # CCT Configuration
     cct_cutoff = db.Column(db.Float, nullable=True)
     cct_triggers = db.Column(db.Integer, nullable=True)
     cct_trials_per_trigger = db.Column(db.Integer, nullable=True)
     cct_valid = db.Column(db.Integer, nullable=True)
 
+    # CCT Metrics
     cct_none_pct = db.Column(db.Float, nullable=True)
     cct_rt_mean = db.Column(db.Integer, nullable=True)
     cct_mean = db.Column(db.Float, nullable=True)
     cct_std = db.Column(db.Float, nullable=True)
     cct_median = db.Column(db.Float, nullable=True)
 
+    # CCT Detailed Results
     cct_per_trigger = db.Column(db.JSON, nullable=True)
     cct_pairwise = db.Column(db.JSON, nullable=True)
-    cct_pass = db.Column(db.Boolean, nullable=True)
+    cct_pass = db.Column(db.Boolean, nullable=True, index=True)
+
+    def __repr__(self):
+        return f"<TestData id={self.id} user={self.user_id} type={self.test_type} pass={self.cct_pass}>"
+
+    def get_consistency_score(self):
+        """Calculate overall consistency score from available metrics"""
+        if self.cct_mean is not None and self.cct_std is not None:
+            # Lower std relative to mean = higher consistency
+            if self.cct_mean > 0:
+                return 1 - min(self.cct_std / self.cct_mean, 1)
+        return None
 
     def to_dict(self):
         return {
@@ -574,7 +607,57 @@ class TestData(db.Model):
             "cct_per_trigger": self.cct_per_trigger,
             "cct_pairwise": self.cct_pairwise,
             "cct_pass": self.cct_pass,
+            "consistency_score": self.get_consistency_score(),
+        }
+
+# ======================================================
+# SCREENING TEST DATA MODELS
+# ======================================================
+
+
+class ScreeningTestData(db.Model):
+    """Stores completed screening test results with scores"""
+    __tablename__ = 'screening_test_data'
+    
+    id = db.Column(db.Integer, primary_key=True)
+    user_id = db.Column(db.Integer, db.ForeignKey('participants.id'), index=True, nullable=False)
+    participant = db.relationship('Participant', backref='screening_test_data', lazy='joined')
+    
+    test_code = db.Column(db.String(50), nullable=False)
+    version = db.Column(db.String(50))
+    started_at = db.Column(db.DateTime)
+    completed_at = db.Column(db.DateTime)
+    status = db.Column(db.String(50))
+    rt_mean_ms = db.Column(db.Integer)
+    accuracy = db.Column(db.Float)
+    consistency_score = db.Column(db.Float)
+    result_label = db.Column(db.String(100))
+    likelihood_score = db.Column(db.Float)
+    recommendation = db.Column(db.String(255))
+    
+    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
+    
+    def __repr__(self):
+        return f"<ScreeningTestData user_id={self.user_id} test={self.test_code}>"
+    
+    def to_dict(self):
+        return {
+            "id": self.id,
+            "user_id": self.user_id,
+            "test_code": self.test_code,
+            "version": self.version,
+            "started_at": self.started_at.isoformat() if self.started_at else None,
+            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
+            "status": self.status,
+            "rt_mean_ms": self.rt_mean_ms,
+            "accuracy": self.accuracy,
+            "consistency_score": self.consistency_score,
+            "result_label": self.result_label,
+            "likelihood_score": self.likelihood_score,
+            "recommendation": self.recommendation,
+            "created_at": self.created_at.isoformat() if self.created_at else None,
         }
+        
 
 class SpeedCongruency(db.Model):
     """
@@ -648,4 +731,77 @@ class SpeedCongruency(db.Model):
             "response_ms": self.response_ms,
             "meta_json": self.meta_json or {},
             "created_at": self.created_at.isoformat() if self.created_at else None,
+        }
+
+# ======================================================
+# ANALYZED TEST DATA MODELS
+# ======================================================
+
+class AnalyzedTestData(db.Model):
+    """Analyzed/processed test results with diagnostic classifications"""
+    __tablename__ = 'analyzed_test_data'
+    __table_args__ = (
+        Index('idx_atd_user_test_created', 'user_id', 'test_id', 'created_at'),
+        Index('idx_atd_user_diagnosis', 'user_id', 'diagnosis'),
+        Index('idx_atd_test_family', 'test_type', 'family'),
+        Index('idx_atd_owner_family', 'owner_researcher_id', 'family'),
+    )
+    
+    id = db.Column(db.Integer, primary_key=True)
+    
+    # Foreign key to Participant
+    user_id = db.Column(db.Integer, db.ForeignKey('participants.id'), index=True, nullable=False)
+    participant = db.relationship('Participant', backref='analyzed_test_data', lazy='joined')
+    
+    # Foreign key to Test
+    test_id = db.Column(db.Integer, db.ForeignKey('tests.id'), nullable=True, index=True)
+    test = db.relationship('Test', backref='analyzed_results', lazy='joined')
+    
+    test_type = db.Column(db.String(50), nullable=True, index=True)
+    
+    # Foreign key to Researcher
+    owner_researcher_id = db.Column(db.Integer, db.ForeignKey('researchers.id'), nullable=True, index=True)
+    researcher = db.relationship('Researcher', backref='analyzed_tests', lazy='joined')
+    
+    # Foreign key to ColorStimulus (if applicable)
+    stimulus_id = db.Column(
+        db.Integer, 
+        db.ForeignKey('color_stimuli.id', ondelete='SET NULL'), 
+        nullable=True, 
+        index=True
+    )
+    stimulus = db.relationship('ColorStimulus', back_populates='analyzed_data_entries', lazy='joined')
+    
+    stimulus_type = db.Column(db.String(50), nullable=True)
+    trial_int = db.Column(db.Integer, nullable=True)
+    
+    # Test family: 'color', 'gustatory', 'space', etc.
+    family = db.Column(db.String(50), nullable=False, default='color', index=True)
+    
+    session_id = db.Column(db.Integer, nullable=True, index=True)
+    locale = db.Column(db.String(10), nullable=True)
+    
+    # Diagnostic outcome - True indicates positive diagnosis for synesthesia
+    diagnosis = db.Column(db.Boolean, nullable=True, index=True)
+    
+    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
+    
+    def __repr__(self):
+        return f"<AnalyzedTestData id={self.id} user={self.user_id} test={self.test_type} diagnosis={self.diagnosis}>"
+    
+    def to_dict(self):
+        return {
+            "id": self.id,
+            "user_id": self.user_id,
+            "test_id": self.test_id,
+            "test_type": self.test_type,
+            "owner_researcher_id": self.owner_researcher_id,
+            "stimulus_id": self.stimulus_id,
+            "stimulus_type": self.stimulus_type,
+            "trial_int": self.trial_int,
+            "family": self.family,
+            "session_id": self.session_id,
+            "locale": self.locale,
+            "diagnosis": self.diagnosis,
+            "created_at": self.created_at.isoformat() if self.created_at else None,
         }
\ No newline at end of file
-- 
2.46.1

